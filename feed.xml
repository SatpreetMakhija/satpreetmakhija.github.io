<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://satpreetmakhija.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://satpreetmakhija.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-02T09:16:20+00:00</updated><id>https://satpreetmakhija.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">The Messiah of Empty Highs</title><link href="https://satpreetmakhija.github.io/blog/2025/the-messiah-of-empty-highs/" rel="alternate" type="text/html" title="The Messiah of Empty Highs"/><published>2025-01-30T00:00:00+00:00</published><updated>2025-01-30T00:00:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2025/the-messiah-of-empty-highs</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2025/the-messiah-of-empty-highs/"><![CDATA[<p><em>Disclaimer: The matter to be discussed can be yielded in symbols that you know only in facts or in experience that you already have. The latter is chosen. Writing much of the below seems redundant to the extent that writing it feels repugnant. Yet, we shall endure because you have forgotten it all and need a friendly reminder.</em></p> <p>She kneels behind the door, breathing shallow, anticipation thick in the air. With steady hands, she lays a line of coke across her chest‚Äîcareful, deliberate, chest up to ensure the line doesn‚Äôt slip inside. Behind her, the queue stretches long, each bearing their finest, eager for their moment. They‚Äôve come to serve. The messiah opens the door. A sniff, deep and hungry. A hit. It fades quickly. He craves more. Many more. He looks up, eyes scanning, and the queue suddenly seems too short.</p> <p>That queue is your Instagram feed, and you are their messiah.</p> <p>Them lines of joy have never been of better quality. Refined, and then refined some more. Movies have not been shot better, writing has never been sharper, food has never been tastier, music has never been richer‚Äîand yet, their impact has never been lower. This is the paradox of today.</p> <p>A great movie is not just its runtime‚Äîit‚Äôs everything that precedes it. The quiet, the build-up, the anticipation. How can you <em>see</em> a movie when you see them all the time, huh? You do not taste when you never stop munching. You do not hear when there never is silence. The constant strips you of the ever-present.</p> <p>You <em>need</em> its absence to enjoy its presence.</p> <p>A hard slap on a cold morning is felt. One too many, and you‚Äôre numb. Don‚Äôt become numb. If not, the subtleties that make life <em>life</em> will elude you forever.</p>]]></content><author><name></name></author><category term="creative"/><category term="essay"/><category term="philosophy"/><category term="modern life"/><summary type="html"><![CDATA[On diminishing returns of stimulation.]]></summary></entry><entry><title type="html">Your Codebase Reeks of Database Coupling; Here‚Äôs the Fix</title><link href="https://satpreetmakhija.github.io/blog/2025/db-and-server/" rel="alternate" type="text/html" title="Your Codebase Reeks of Database Coupling; Here‚Äôs the Fix"/><published>2025-01-29T00:00:00+00:00</published><updated>2025-01-29T00:00:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2025/db-and-server</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2025/db-and-server/"><![CDATA[<p><strong>Ask yourself</strong>: <em>If I had to change the database in my codebase today, do I know what needs to be done?</em></p> <p>Chances are your palms are sweating, and you won‚Äôt be able to sleep tonight from such a horrifying question. If not, you don‚Äôt need this post. For others, keep reading to sleep better tonight.</p> <p>We‚Äôve all been through the arduous journey of building an application. You choose a database and stick with it. You don‚Äôt even question what if I need to change the database and for good reasons. The current database‚Äôs limitations reveals itself only when your application has high traffic. There are more reads, more writes, more updates that leads to sharding, indexing and what not. Let‚Äôs be honest, most of your applications don‚Äôt reach that state, if any. So, why bother?</p> <p>Good programming practices.</p> <p>Enough attention is paid to decoupling functions, objects, and classes in codebases, yet databases are often treated as immutable choices. Even if your database never changes, structuring your code to allow for such a change brings clarity and maintainability. Wouldn‚Äôt it be reassuring to know that you could switch from MySQL to PostgreSQL with minimal effort?</p> <h3 id="the-north-star-abstraction">The North Star: Abstraction</h3> <p>Our goal is to organize the codebase so that switching databases is not impossible. The key is abstractions, spoiler alert. We‚Äôll walk through an example of the proverbial software, a web app, below and see how to avoid decoupling of database with your codebase.</p> <p>Your web app has a backend written in Go and a PostgreSQL database. You‚Äôve created a <code class="language-plaintext highlighter-rouge">users</code> table and defined a corresponding struct:</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">CREATE</span> <span class="k">TABLE</span> <span class="n">users</span> <span class="p">(</span>
    <span class="n">id</span> <span class="nb">SERIAL</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
    <span class="n">name</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
    <span class="n">email</span> <span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
    <span class="n">age</span> <span class="nb">INT</span>
<span class="p">);</span>
</code></pre></div></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">User</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">ID</span>    <span class="kt">int</span>
    <span class="n">Name</span>  <span class="kt">string</span>
    <span class="n">Email</span> <span class="kt">string</span>
    <span class="n">Age</span>   <span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div> <p>A new feature requires offering discounts to users who‚Äôve been active for six months. You add a <code class="language-plaintext highlighter-rouge">created_at</code> field to your database schema but fail to update the Go struct. This schema-struct inconsistency is your first mistake. A mismatch between the database schema and its in-memory representation is a ticking time bomb. The <code class="language-plaintext highlighter-rouge">user</code> struct is to store the idea of a user in memory. Why would you want an inconsistency between what‚Äôs stored in the table versus what‚Äôs present in memory? You‚Äôre asking for trouble when you do that.</p> <p>üëâ <strong>Always maintain a consistent mapping between table schemas and corresponding data structures.</strong></p> <h3 id="introducing-abstractions">Introducing Abstractions</h3> <p>You have an HTTP handler called <code class="language-plaintext highlighter-rouge">SignInHandler</code> whose job is to sign in users when they login for the first time. The <code class="language-plaintext highlighter-rouge">SignInHandler</code> must create users in the database, but it shouldn‚Äôt know the specific database being used. To achieve this, introduce two abstractions:</p> <ol> <li><strong>Repository abstraction</strong>: Handles direct database interactions.</li> <li><strong>Model abstraction</strong>: Bridges business logic with the repository.</li> </ol> <h4 id="the-repository-layer">The Repository Layer</h4> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">UserRepo</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">CreateUser</span><span class="p">(</span><span class="n">user</span> <span class="n">User</span><span class="p">)</span> <span class="kt">error</span>
    <span class="n">GetUserByEmail</span><span class="p">(</span><span class="n">email</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// PostgreSQL implementation of UserRepo</span>
<span class="k">type</span> <span class="n">UserRepoPostgres</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">db</span> <span class="o">*</span><span class="n">sql</span><span class="o">.</span><span class="n">DB</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">UserRepoPostgres</span><span class="p">)</span> <span class="n">CreateUser</span><span class="p">(</span><span class="n">user</span> <span class="n">User</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">Exec</span><span class="p">(</span><span class="s">"INSERT INTO users (name, email, age) VALUES ($1, $2, $3)"</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">Email</span><span class="p">,</span> <span class="n">user</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">err</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">r</span> <span class="o">*</span><span class="n">UserRepoPostgres</span><span class="p">)</span> <span class="n">GetUserByEmail</span><span class="p">(</span><span class="n">email</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">User</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">user</span> <span class="n">User</span>
    <span class="n">err</span> <span class="o">:=</span> <span class="n">r</span><span class="o">.</span><span class="n">db</span><span class="o">.</span><span class="n">QueryRow</span><span class="p">(</span><span class="s">"SELECT id, name, email, age FROM users WHERE email=$1"</span><span class="p">,</span> <span class="n">email</span><span class="p">)</span><span class="o">.</span>
        <span class="n">Scan</span><span class="p">(</span><span class="o">&amp;</span><span class="n">user</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">.</span><span class="n">Name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">.</span><span class="n">Email</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">user</span><span class="o">.</span><span class="n">Age</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
        <span class="k">return</span> <span class="no">nil</span><span class="p">,</span> <span class="n">err</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">user</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div> <p>The interface ensures flexibility‚Äîyou can replace the database implementation without affecting consumers of <code class="language-plaintext highlighter-rouge">UserRepo</code>.</p> <h4 id="the-model-layer">The Model Layer</h4> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">UserModel</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">repo</span> <span class="n">UserRepo</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">UserModel</span><span class="p">)</span> <span class="n">CreateUser</span><span class="p">(</span><span class="n">user</span> <span class="n">User</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">user</span><span class="o">.</span><span class="n">Age</span> <span class="o">&lt;</span> <span class="m">18</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s">"user must be an adult"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">repo</span><span class="o">.</span><span class="n">CreateUser</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>At first, this may seem redundant‚Äîwhy have <code class="language-plaintext highlighter-rouge">CreateUser</code> in both repository and model layers? But here‚Äôs a golden rule:</p> <p>üëâ <strong>Only models should interact with repositories‚Äîno other part of the codebase should invoke repositories directly.</strong></p> <p>This boundary ensures:</p> <ul> <li>The repository layer only handles database interactions.</li> <li>The model layer orchestrates business logic before invoking the repository.</li> <li>Handlers (like <code class="language-plaintext highlighter-rouge">SignInHandler</code>) remain oblivious to the database implementation.</li> </ul> <p>You should note that the way we have setup the abstractions interaction, the <code class="language-plaintext highlighter-rouge">SignInHandler</code> knows only of the user model and user model knows only of the repository interface.</p> <h3 id="switching-databases">Switching Databases</h3> <p>Returning to our original question: <em>Where exactly do we need to make changes to switch databases?</em> Let‚Äôs say we‚Äôll move from Postgres to MySQL. To do so, we do the following:</p> <ol> <li>Implement a new struct, <code class="language-plaintext highlighter-rouge">UserRepoMySQL</code>, that adheres to <code class="language-plaintext highlighter-rouge">UserRepo</code>.</li> <li>Use <code class="language-plaintext highlighter-rouge">UserRepoMySQL</code> instead of <code class="language-plaintext highlighter-rouge">UserRepoPostgres</code> when instantiating <code class="language-plaintext highlighter-rouge">UserModel</code>.</li> <li>Everything else‚Äîbusiness logic, handlers, logging‚Äîremains unchanged.</li> </ol> <p>This structured approach ensures that <strong>only the repository layer changes</strong> during a database migration. There is a trade-off here. As your app codebase increases, you‚Äôll have many repository interfaces and when you perform a database switch, you will have to reimplement these interfaces from scratch. That‚Äôs a lot of work. But, your business logic won‚Äôt need reimplementation as that stays in the model layer only. All other abstractions such as http handlers, loggers, etc too remain as is. That‚Äôs a trade-off worth the repository interface reimplementation.</p> <p>üëâ <strong>Software doesn‚Äôt become cumbersome when there‚Äôs a lot to do‚Äîit becomes cumbersome when you can‚Äôt pinpoint <em>where</em> things need to change.</strong></p> <p>Note, An actual database migration involves handling downtime, data transfer, and phased rollouts. But if your codebase follows these principles, switching databases becomes feasible at least from the codebase point of view.</p> <h3 id="faqs">FAQs</h3> <p><strong>Why not just merge repositories and models?</strong></p> <p>Business logic often extends beyond database operations. For example, if you need to trigger an ETL job when fetching high-spending users, this logic belongs in the model, not the repository. Keeping them separate prevents unnecessary complexity in database interactions.</p> <p><strong>I won‚Äôt change my database type. Should I care?</strong></p> <p>Yes! Even if your database remains unchanged, separating business logic from database interactions improves maintainability. Your codebase becomes easier to extend and debug.</p> <p><strong>What if data types differ between databases (e.g., MySQL vs. PostgreSQL)?</strong></p> <p>Rather than changing the core application logic, use helper functions to transform data types at the repository level. This keeps the rest of your application agnostic to database-specific differences.</p>]]></content><author><name></name></author><category term="Software Engineering"/><category term="Databases"/><category term="Go"/><category term="Database"/><category term="Software Design"/><category term="Abstraction"/><summary type="html"><![CDATA[A guide on how to maintain your codebase for easy database switch]]></summary></entry><entry><title type="html">Choosing the right axioms</title><link href="https://satpreetmakhija.github.io/blog/2025/choosing-the-right-axioms/" rel="alternate" type="text/html" title="Choosing the right axioms"/><published>2025-01-05T00:00:00+00:00</published><updated>2025-01-05T00:00:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2025/choosing-the-right-axioms</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2025/choosing-the-right-axioms/"><![CDATA[<p>I recently went down the rabbit hole of studying Real Analysis. As part of the first exercise, we constructed natural numbers using <strong>Peano‚Äôs axioms</strong>. One of these axioms is often described as ‚Äúensuring no circularity‚Äù‚Äîmeaning we don‚Äôt define a natural number in terms of itself or create logical loops. Essentially, it‚Äôs the idea that \(0\) (or the ‚Äúfirst‚Äù natural number) is not the successor of any other number. This ensures you can‚Äôt keep going backwards indefinitely and end up with something like ‚Äúthis number created itself.‚Äù</p> <p>This made me wonder: <strong>How do we choose the correct axioms in the first place?</strong></p> <p>I had a vague sense of what an axiom stands for: it‚Äôs something so fundamental that we just accept it, because denying it seems impossible if we want to build a coherent theory. For example, we accept the ‚Äúno circularity‚Äù rule in Peano arithmetic because we know, from our usual understanding of how counting works, that numbers don‚Äôt loop back on themselves.</p> <p>In some sense, defining axioms is a backward process rather than a forward one: we look at the structures we already use‚Äîlike arithmetic‚Äîand peel back the layers to find the simplest building blocks. For instance:</p> <ul> <li><strong>Multiplication</strong> can be defined as repeated addition.</li> <li><strong>Addition</strong> can be defined as repeated increment.</li> <li><strong>Increment</strong> (the ‚Äúsuccessor‚Äù operation) is often written as \(n \mapsto n + 1\) and is the point where we say, ‚ÄúOkay, we can‚Äôt break this down further.‚Äù</li> </ul> <p>So we stop at increment and make it an axiom: ‚ÄúThere exists a successor function that behaves in this fundamentally simple way.‚Äù We basically say, ‚ÄúWe can‚Äôt derive it from anything more basic, so we accept it as foundational.‚Äù</p> <p>Now, look at <strong>Euclidean geometry</strong>. It‚Äôs famously built from five postulates (axioms):</p> <ol> <li>A straight line segment can be drawn between any two points.</li> <li>Any finite straight line segment can be extended indefinitely in a straight line.</li> <li>A circle can be drawn with any center and any distance (radius).</li> <li>All right angles are equal to one another.</li> <li><em>(The Parallel Postulate)</em> If a straight line intersects two other straight lines such that the sum of the interior angles on one side is less than two right angles, those two lines (if extended far enough) will meet on that side.</li> </ol> <p>The first four seem pretty straightforward‚Äîbasically describing how lines, segments, and circles behave. But the fifth one, the <strong>Parallel Postulate</strong>, says that if lines have certain angle properties, they‚Äôll meet (or never meet) under certain conditions. Historically, Euclid tried to derive this from the first four but couldn‚Äôt. After centuries of attempts, mathematicians concluded the parallel postulate must stand on its own‚Äîso it‚Äôs part of the foundation.</p> <p>I recently read (in the footnotes of a book whose name I‚Äôve unfortunately forgotten) a neat idea from <strong>Bertrand Russell</strong>. He suggested that one way we judge the strength or validity of our axioms is whether they lead us to statements we <em>already believe</em> to be true. So, for the natural numbers, we already have the idea that we can keep incrementing a number forever and it‚Äôll keep getting bigger. That‚Äôs why we accept an axiom like \(n + 1 &gt; n\) ‚Äîit neatly matches our intuition that numbers don‚Äôt loop back on themselves and can grow indefinitely.</p> <p>Here are a few general guidelines we can gather from this:</p> <ol> <li><strong>Work backwards</strong> to find the axioms that cannot be further derived.</li> <li><strong>Accept as axioms</strong> those that seem both intuitively reasonable and resistant to being proved by other axioms.</li> <li><strong>Use earlier results</strong> (like known theorems or observed truths) to test whether your axioms are powerful or consistent enough.</li> </ol> <p>The short version to choosing the right axioms is: we figure out the irreducible pieces, test them against what we think is ‚Äúobviously true,‚Äù and then put them at the foundation of our system. That‚Äôs all ‚Äúaxioms‚Äù really are‚Äîrock-bottom assumptions that shape the entire universe that follows.</p> <p>To be honest, writing this post does make me wonder if I can do the same for choosing the right axioms to lead my life. I‚Äôll tackle this in another post.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[A framework to help you choose the right axioms]]></summary></entry><entry><title type="html">How to avoid prompt injection attack by following prompt engineering best practices?</title><link href="https://satpreetmakhija.github.io/blog/2023/prompt-injection-attack/" rel="alternate" type="text/html" title="How to avoid prompt injection attack by following prompt engineering best practices?"/><published>2023-07-11T17:39:00+00:00</published><updated>2023-07-11T17:39:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2023/prompt-injection-attack</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2023/prompt-injection-attack/"><![CDATA[<p>Redirecting to another page.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[using language models in production comes with its own risks. Read the article to learn how to mitigate them.]]></summary></entry><entry><title type="html">GPUs: Why you can never have enough?</title><link href="https://satpreetmakhija.github.io/blog/2023/GPUs-substack-article/" rel="alternate" type="text/html" title="GPUs: Why you can never have enough?"/><published>2023-04-28T17:39:00+00:00</published><updated>2023-04-28T17:39:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2023/GPUs-substack-article</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2023/GPUs-substack-article/"><![CDATA[<p>Redirecting to another page.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[the real reason why GPUs are in demand and why it's not going to stop]]></summary></entry><entry><title type="html">Context Revolution: Taking machines beyond algorithm</title><link href="https://satpreetmakhija.github.io/blog/2023/Context-Revolution/" rel="alternate" type="text/html" title="Context Revolution: Taking machines beyond algorithm"/><published>2023-02-07T17:39:00+00:00</published><updated>2023-02-07T17:39:00+00:00</updated><id>https://satpreetmakhija.github.io/blog/2023/Context-Revolution</id><content type="html" xml:base="https://satpreetmakhija.github.io/blog/2023/Context-Revolution/"><![CDATA[<p>The computation revolution started when we built general purpose computers to follow instructions. A computer follows an algorithm step by step. It doesn‚Äôt need to <i>understand</i> the algorithm.</p> <p>Here‚Äôs an example to illustrate the difference between <i>understanding</i> something and following an algorithm. There‚Äôs a world renowned chef, Andre, who makes a special pasta dish. Andre lost both his arms (sorry Andre). He hires you to make this dish. You don‚Äôt know anything about how to make this dish. You don‚Äôt know these ingredients, how they taste, which ones blend together. But, Andre is great at communication. He gives you step by step procedure to make the dish and you follow along with him. Voila! You made the special pasta only Andre knows how to make. Andre <i>understands</i> how to make this special pasta. You followed an algorithm. But what is it that Andre has that you don‚Äôt? Context. He knows the flavour of the ingredients, he knows what they taste like, he knows which ingredients complement each other and which don‚Äôt. He has context around the algorithm. This context is what I proxy for as understanding.</p> <p>The AI revolution is about giving computers more context around the computation they perform.</p> <p>‚ÄúWrite me a function to add five numbers.‚Äù - you give the prompt to a language model that runs on a computer. The computer doesn‚Äôt have an algorithm to give you the output you want. It only knows how to execute an algorithm. The language model contains the context to make head and tails of the prompt. We will provide this context to computers via AI such as natural language, our physical reality, our visual imagery, anything and everything we have access to. With time they will have as much context as we do. This is what I call the Context Revolution.</p>]]></content><author><name></name></author><summary type="html"><![CDATA[how AI changes computations performed by a computer]]></summary></entry></feed>